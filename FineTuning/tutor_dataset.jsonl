{"prompt": "¿Qué es un algoritmo?", "response": "Un algoritmo es un conjunto de instrucciones paso a paso que permite realizar una tarea o resolver un problema."}
{"prompt": "En qué consiste el análisis de flujo en programación?", "response": "El análisis de flujo se refiere al estudio de cómo las instrucciones se ejecutarán en un programa, y se utiliza para identificar posibles errores u optimizar la eficiencia del código."}
{"prompt": "¿Qué es una estructura de datos?", "response": "Una estructura de datos es un conjunto organizado de datos que permite acceder a ellos de manera rápida y eficiente. Hay muchas estructuras disponibles, como listas, diccionarios, matrices, etc."}
{"prompt": "Describe la diferencia entre un algoritmo recursivo y un algoritmo iterativo.", "response": "Un algoritmo recursivo utiliza la llamada a sí mismo para resolver una tarea, mientras que un algoritmo iterativo realiza operaciones repetitivas sin depender de la propia función. El algoritmo iterativo suele ser más eficiente."}
{"prompt": "Explica la importancia del manejo de errores en programación.", "response": "Manejar los errores permite que las aplicaciones sigan funcionando incluso cuando se produce un fallo inesperado o un dato incorrecto, evitando que el programa se cierre y asegurando la estabilidad del código."}
{"prompt": "Explique la función de una función lambda.", "response": "Una función lambda es una función corta y reutilizable, sin necesidad de definirla con un nombre. Se utiliza cuando se necesita realizar una operación específica dentro de un programa."}
{"prompt": "¿Qué es el bucle for? ¿Cuál es su utilidad?", "response": "El bucle for permite iterar sobre un conjunto de elementos repetidamente y ejecutar código para cada uno. Es útil para operaciones repetitivas."}
{"prompt": "Explica la diferencia entre una condición y un bloque de código.", "response": "Una condición determina si un bloque de código se ejecuta. Un bloque de código es un conjunto de instrucciones que se ejecutan cuando la condición se cumple."}
{"prompt": "¿Qué significa la palabra clave 'break' en programación?", "response": "La palabra clave 'break' detiene el bucle actual y sale de él, mientras que 'continue' pasa al siguiente elemento del bucle."}
{"prompt": "Describe el concepto de programación dinámica.", "response": "La programación dinámica es una técnica para resolver problemas dividiéndolos en subproblemas más pequeños y almacenando sus soluciones para evitar cálculos repetidos."}
{"prompt": "¿Qué es una función de prueba? ¿Para qué se utiliza?", "response": "Una función de prueba es código diseñado para verificar que un programa funciona correctamente, detectando errores o fallos."}
{"prompt": "¿Qué es una variable?", "response": "Una variable es un nombre utilizado para almacenar datos en un programa."}
{"prompt": "Explica la diferencia entre una variable y un valor.", "response": "Una variable es el nombre que se asigna para almacenar un valor. El valor es la información real guardada en la variable."}
{"prompt": "Enumera los tipos de datos básicos que existen en programación.", "response": "Los tipos de datos básicos incluyen texto (string), números (integer, float) y booleanos (true o false)."}
{"prompt": "¿Cómo se asigna un valor a una variable en Python?", "response": "Se asigna un valor usando el símbolo '='."}
{"prompt": "Describe la importancia del control de flujo en programación.", "response": "El control de flujo permite que las instrucciones de un programa se ejecuten en un orden específico, haciendo posible la creación de programas lógicos y eficientes."}
{"prompt": "Explica el concepto de función en programación.", "response": "Una función es una unidad de código reutilizable que realiza una tarea específica. Se puede llamar varias veces para automatizar tareas repetitivas."}
{"prompt": "¿Qué significa la palabra clave 'if' en programación?", "response": "La palabra clave 'if' permite ejecutar código si se cumple una condición."}
{"prompt": "En qué contexto se utiliza la palabra clave 'for' en programación?", "response": "La palabra clave 'for' se utiliza para iterar sobre elementos y ejecutar código para cada uno."}
{"prompt": "Explica las ventajas de utilizar métodos en programación.", "response": "Los métodos ayudan a reutilizar código, mejorar la legibilidad y facilitar el mantenimiento del programa."}
{"prompt": "Describe la diferencia entre una variable local y una variable global en una función.", "response": "Una variable local solo existe dentro de la función donde se declara. Una variable global puede usarse desde cualquier parte del programa."}
{"prompt": "Qué es una variable constante en programación?", "response": "Una variable constante tiene un valor fijo que no se puede modificar durante la ejecución del programa. Se usa para almacenar información fija o valores predefinidos."} 
{"prompt": "Explica la diferencia entre una variable de tipo entero y una variable de tipo float.", "response": "Una variable de tipo entero almacena solo números enteros (sin decimales) como -10, 0, 10. Una variable de tipo float almacena valores decimales con precisión. Ejemplo: 3.14 o -2.7."}
{"prompt": "¿Cómo se crea una estructura de datos en Python?", "response": "En Python, las estructuras de datos como listas, diccionarios y tuplas se crean usando sus respectivos nombres.  Por ejemplo, una lista se crea con los elementos separados por comas: [1, 2, 3], un diccionario con llaves y valores separados por comas: {'nombre': 'Juan', 'edad': 25}." }
{"prompt": "Describe la diferencia entre una variable local y una variable global en una función.", "response": "Una variable local es accesible dentro de la función donde se declara, mientras que una variable global puede ser utilizada desde cualquier parte del programa."} 
{"prompt": "Explica el concepto de programación orientada a objetos (OOP).", "response": "La programación orientada a objetos (OOP) utiliza clases y objetos para modularizar el código, aumentar la reutilización de código y facilitar la comprensión del programa. Ejemplo: Una clase 'Persona' con atributos como 'nombre', 'edad', y métodos como 'mostrarInformacion'."}
{"prompt": "Describe los tipos de datos principales que existen en programación.", "response": "Los tipos de datos principales son: texto (string), números (integer, float) y booleanos (true o false)." } 
{"prompt": "Explica el concepto de una función anónima en Python.", "response":  "Una función anónima es una función sin un nombre definido. Se crea en la misma línea donde se utiliza y puede utilizarse para realizar operaciones simples."}
{"prompt": "Qué es la gestión de memoria en programación?", "response": "La gestión de memoria es el proceso de asignar, controlar y liberar espacio de memoria para que las aplicaciones funcionen correctamente.  Es esencial para el rendimiento del programa y evitar problemas como el 'memory leak'." }
{"prompt": "Explícame qué es una variable en programación.", "response": "Una variable es un espacio donde guardas un valor. En Python, por ejemplo: x = 10 ..."}
{"prompt": "Corrige este error en C: printf(\"%d\",x)","response": "Falta un punto y coma al final y debes asegurar que x esté declarado. Quedaría así: printf(\"%d\", x);"}
{"prompt": "Enséñame recursión con un ejemplo simple.","response": "La recursión ocurre cuando una función se llama a sí misma. Ejemplo clásico: factorial(n) ..."}
{"prompt": "Hazme un ejercicio de loops en JavaScript nivel fácil.","response": "Claro. Ejercicio: escribe un for que imprima del 1 al 10..."}
{"prompt": "¿Qué es un puntero en C?","response": "Un puntero almacena la dirección de memoria de otra variable. Por ejemplo: int *p = &x;"}
{"prompt": "¿Qué es una función en programación y por qué es útil?", "response": "Una función es un bloque de código con un nombre que puedes llamar varias veces para realizar una tarea específica. Es útil porque evita repetir código, mejora la organización y facilita la corrección de errores. Por ejemplo: saludar() podría imprimir '¡Hola!' cada vez que la llamas."}
{"prompt": "¿Qué significa 'depurar' un programa?", "response": "Depurar (o hacer debugging) es el proceso de encontrar y corregir errores (bugs) en el código. Puedes usar mensajes de error, imprimir valores intermedios o herramientas como el depurador de tu editor para entender qué está fallando."}
{"prompt": "¿Qué es un comentario en programación y para qué sirve?", "response": "Un comentario es texto que escribes en tu código para explicar qué hace una parte del programa. El ordenador lo ignora al ejecutar. En Python se escribe con #, y en muchos lenguajes con // o /* ... */. Sirve para que tú y otros entiendan mejor el código."}
{"prompt": "¿Qué diferencia hay entre =, == y != en programación?", "response": "= asigna un valor a una variable (x = 5). == compara si dos valores son iguales (x == 5 → true o false). != compara si son distintos (x != 3 → true si x no es 3)."}
{"prompt": "¿Qué es un 'bucle while' y cuándo se usa?", "response": "Un bucle while repite un bloque de código mientras una condición sea verdadera. Por ejemplo, mientras el usuario no escriba 'salir', sigue pidiendo comandos. Es útil cuando no sabes cuántas veces se repetirá el ciclo de antemano."}
{"prompt": "Enséñame un ejemplo sencillo de condicional 'if-else'.", "response": "Claro: edad = 16\nif edad >= 18:\n    print('Eres mayor de edad')\nelse:\n    print('Eres menor de edad')\nEste código imprime 'Eres menor de edad'."}
{"prompt": "¿Qué es una lista en programación?", "response": "Una lista es una colección ordenada de elementos (números, textos, etc.) que puedes modificar. En Python: frutas = ['manzana', 'banana', 'naranja']. Puedes acceder a cada elemento por su posición (índice), empezando en 0."}
{"prompt": "¿Qué es un índice en una lista?", "response": "El índice es la posición de un elemento dentro de una lista. Empieza en 0. Por ejemplo, en ['gato', 'perro'], 'gato' está en el índice 0 y 'perro' en el índice 1."}
{"prompt": "¿Qué es un 'string' y cómo se crea?", "response": "Un string es una cadena de texto. Se crea poniendo el texto entre comillas, simples o dobles. Ejemplos: nombre = 'Ana' o saludo = \"Hola mundo\"."}
{"prompt": "¿Qué pasa si intento dividir un número entre cero?", "response": "En la mayoría de lenguajes (como Python), dividir entre cero produce un error de ejecución (ZeroDivisionError). Es importante comprobar antes si el divisor es cero para evitar que el programa se detenga."}
{"prompt": "¿Qué es una 'clase' en programación orientada a objetos?", "response": "Una clase es como un molde o plantilla para crear objetos. Define atributos (características) y métodos (acciones). Por ejemplo, la clase 'Coche' podría tener atributos como 'marca' y 'color', y un método 'arrancar()'."}
{"prompt": "¿Qué es un 'objeto' en programación?", "response": "Un objeto es una instancia de una clase. Es un elemento concreto creado a partir de la plantilla. Por ejemplo, si 'Coche' es la clase, un objeto sería mi_coche = Coche('Toyota', 'rojo')."}
{"prompt": "¿Qué es un IDE y para qué sirve?", "response": "Un IDE (Entorno de Desarrollo Integrado) es una aplicación que combina editor de código, ejecución, depuración y otras herramientas en un solo lugar. Ejemplos: VS Code, PyCharm, o Thonny. Ayuda a programar más rápido y con menos errores."}
{"prompt": "¿Qué es la indentación y por qué es importante en Python?", "response": "La indentación es el espacio o tabulación al inicio de una línea. En Python, define qué instrucciones pertenecen a una función, bucle o condicional. A diferencia de otros lenguajes, aquí es obligatoria: sin ella, el programa falla."}
{"prompt": "¿Qué significa 'ejecutar' un programa?", "response": "Ejecutar un programa significa que la computadora lee y lleva a cabo las instrucciones que escribiste, paso a paso, desde la primera hasta la última (o hasta que se detenga)."}
{"prompt": "¿Qué es una 'librería' en programación?", "response": "Una librería (o biblioteca) es un conjunto de funciones y herramientas ya escritas que puedes usar en tu programa. Por ejemplo, en Python, 'math' tiene funciones como sqrt() para raíces cuadradas, y 'random' para generar números aleatorios."}
{"prompt": "¿Cómo puedo saber qué tipo de dato tiene una variable en Python?", "response": "Usa la función type(). Ejemplo: x = 42; print(type(x)) → muestra <class 'int'>. Así sabes si es entero, texto, lista, etc."}
{"prompt": "¿Qué es un 'input' y un 'output' en programación?", "response": "Input (entrada) es la información que el programa recibe (del teclado, un archivo, etc.). Output (salida) es lo que el programa muestra o guarda (en pantalla, en un archivo, etc.). Todo programa trabaja con entradas, procesamiento y salidas."}
{"prompt": "¿Qué es un 'error de sintaxis'?", "response": "Un error de sintaxis ocurre cuando escribes código que no sigue las reglas del lenguaje: faltan paréntesis, comillas, dos puntos, o hay palabras mal escritas. El programa ni siquiera se ejecuta hasta que lo corrijas."}
{"prompt": "¿Qué es 'pseudo-código' y por qué se usa?", "response": "El pseudo-código es una descripción informal de un algoritmo, con palabras y estructuras parecidas a la programación, pero sin reglas estrictas de un lenguaje. Se usa para planificar el código antes de escribirlo, especialmente en equipos o para pensarlo con calma."}
{"prompt": "¿Cómo abordar un problema recursivo por primera vez?", "response": "Sigue estos 3 pasos: 1) Identifica el caso base (cuándo la recursión debe detenerse). 2) Define el caso recursivo: cómo reduces el problema a una versión más pequeña. 3) Asegúrate de que cada llamada se acerque al caso base. Ejemplo: para factorial, el caso base es n=0 (0! = 1), y el caso recursivo es n! = n * (n-1)!."}
{"prompt": "Enséñame a calcular el factorial de un número usando recursión.", "response": "Claro. El factorial de n (n!) es el producto de todos los enteros positivos hasta n. Usamos recursión: \n\ndef factorial(n):\n    if n == 0:  # caso base\n        return 1\n    else:        # caso recursivo\n        return n * factorial(n - 1)\n\nprint(factorial(4))  # → 24 (4*3*2*1)"}
{"prompt": "¿Por qué es importante el caso base en recursión?", "response": "El caso base es la condición de salida de la recursión. Sin él, la función se llamaría a sí misma infinitamente y causaría un error ('RecursionError' en Python). Piensa en una escalera: el caso base es el último escalón; sin él, seguirías bajando para siempre."}
{"prompt": "¿Cómo resolver la suma de los primeros n números naturales con recursión?", "response": "Puedes pensar: suma(n) = n + suma(n-1), y suma(0) = 0 (caso base).\n\ndef suma_n(n):\n    if n == 0:\n        return 0\n    return n + suma_n(n - 1)\n\nprint(suma_n(5))  # → 15 (5+4+3+2+1+0)"}
{"prompt": "¿Cómo invertir una cadena usando recursión?", "response": "Idea: una cadena invertida es el último carácter + la cadena restante invertida. Caso base: cadena vacía o de 1 caracter.\n\ndef invertir(s):\n    if len(s) <= 1:\n        return s\n    return s[-1] + invertir(s[:-1])\n\nprint(invertir('hola'))  # → 'aloh'"}
{"prompt": "¿Cómo saber si una palabra es palíndromo con recursión?", "response": "Un palíndromo se lee igual al derecho y al revés. Compara el primer y último carácter; si coinciden, revisa la subcadena interior. Caso base: 0 o 1 carácter → sí es palíndromo.\n\ndef es_palindromo(s):\n    s = s.lower().replace(' ', '')  # normaliza\n    if len(s) <= 1:\n        return True\n    if s[0] != s[-1]:\n        return False\n    return es_palindromo(s[1:-1])"}
{"prompt": "¿Cómo calcular la potencia (base^exponente) con recursión?", "response": "Usa: base^exp = base * base^(exp-1), y base^0 = 1.\n\ndef potencia(base, exp):\n    if exp == 0:\n        return 1\n    return base * potencia(base, exp - 1)\n\nprint(potencia(2, 3))  # → 8"}
{"prompt": "¿Cómo resolver la secuencia de Fibonacci con recursión?", "response": "Fibonacci: F(0)=0, F(1)=1, y F(n)=F(n-1)+F(n-2) para n>1.\n\ndef fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\nprint(fib(6))  # → 8 (0,1,1,2,3,5,8)"}
{"prompt": "¿Por qué la recursión simple de Fibonacci es lenta para números grandes?", "response": "Porque recalcula los mismos valores muchas veces (ej. fib(3) se calcula desde fib(5), fib(4), etc.). Esto lleva a una explosión exponencial de llamadas. Solución avanzada: 'memoización' (guardar resultados ya calculados) — pero eso es para después de dominar la recursión básica."}
{"prompt": "¿Cómo contar cuántos dígitos tiene un número entero usando recursión?", "response": "Idea: cada llamada divide el número entre 10 (entero), y suma 1. Caso base: número < 10 → 1 dígito.\n\ndef contar_digitos(n):\n    n = abs(n)  # manejamos negativos\n    if n < 10:\n        return 1\n    return 1 + contar_digitos(n // 10)\n\nprint(contar_digitos(1234))  # → 4"}
{"prompt": "¿Cómo encontrar el máximo valor en una lista usando recursión?", "response": "Compara el primer elemento con el máximo del resto de la lista. Caso base: lista de 1 elemento → ese elemento.\n\ndef max_lista(lista):\n    if len(lista) == 1:\n        return lista[0]\n    resto_max = max_lista(lista[1:])\n    return lista[0] if lista[0] > resto_max else resto_max\n\nprint(max_lista([3, 7, 2, 9]))  # → 9"}
{"prompt": "¿Cómo puedo visualizar lo que hace una función recursiva?", "response": "Escribe las llamadas como un árbol o usa print() dentro de la función para ver el flujo. Ejemplo en factorial(3):\n- factorial(3) llama a factorial(2)\n- factorial(2) llama a factorial(1)\n- factorial(1) llama a factorial(0)\n- factorial(0) devuelve 1\n- luego regresa: 1×1=1 → 2×1=2 → 3×2=6."}
{"prompt": "¿Cuándo es mejor usar iteración que recursión?", "response": "Cuando la profundidad puede ser muy grande (pila de llamadas se llena), o cuando el problema es claramente secuencial (como recorrer una lista). La recursión brilla en problemas con estructura 'divide y vencerás': árboles, recorridos, combinaciones, backtracking."}
{"prompt": "¿Cómo resolver el problema de las Torres de Hanoi con recursión?", "response": "Reglas: mueve n discos de A a C usando B como auxiliar, sin poner disco grande sobre uno pequeño.\nSolución recursiva:\n1. Mueve n-1 discos de A a B (usando C)\n2. Mueve el disco grande de A a C\n3. Mueve n-1 discos de B a C (usando A)\nCaso base: n=1 → mueve directamente.\nEs un ejemplo clásico de cómo la recursión simplifica un problema aparentemente complejo."}
{"prompt": "Dame un ejercicio de recursión para practicar: suma de dígitos de un número.", "response": "¡Claro! Ejercicio: Escribe una función recursiva que sume los dígitos de un entero positivo.\nEjemplo: suma_digitos(123) → 1+2+3 = 6.\nPista: usa % 10 para el último dígito y // 10 para quitarlo.\nSolución:\ndef suma_digitos(n):\n    if n < 10:\n        return n\n    return (n % 10) + suma_digitos(n // 10)"}
{"prompt": "¿Qué es un grafo en programación?", "response": "Un grafo es una estructura que representa objetos (nodos o vértices) y sus relaciones (aristas). Ejemplo: ciudades (nodos) y carreteras entre ellas (aristas). Se usa en redes sociales, mapas, recomendaciones, etc."}
{"prompt": "¿Cuál es la diferencia entre grafo dirigido y no dirigido?", "response": "En un grafo *no dirigido*, las aristas no tienen dirección: si A está conectado con B, entonces B también lo está con A (como una amistad en Facebook). En un grafo *dirigido*, la conexión tiene sentido: A → B no implica B → A (como seguir a alguien en Twitter)."}
{"prompt": "¿Cómo representar un grafo en código?", "response": "Dos formas comunes: 1) **Lista de adyacencia**: un diccionario donde cada nodo apunta a una lista de sus vecinos. Ej: {'A': ['B', 'C'], 'B': ['A']}. 2) **Matriz de adyacencia**: una tabla (matriz) donde fila i y columna j indican si hay conexión entre nodo i y j (1 = sí, 0 = no)."}
{"prompt": "¿Qué es un algoritmo de ordenamiento?", "response": "Es un método para organizar una lista de elementos (números, palabras, etc.) en un orden específico —generalmente ascendente o descendente. Ejemplo: ordenar [3, 1, 4] → [1, 3, 4]."}
{"prompt": "¿Cómo funciona el algoritmo de ordenamiento por burbuja (bubble sort)?", "response": "Compara pares de elementos adyacentes y los intercambia si están en el orden incorrecto. Repite esto hasta que no haya intercambios. Es simple pero lento para listas grandes. Ejemplo:\n[5, 2, 8] → compara 5 y 2 → intercambia → [2, 5, 8]; luego 5 y 8 → ok. En una segunda pasada, todo está ordenado."}
{"prompt": "¿Por qué el bubble sort no es eficiente?", "response": "Porque en el peor caso (lista invertida) necesita ~n² comparaciones (donde n es el tamaño). Para 1000 elementos, ¡hasta 1 millón de operaciones! Hay algoritmos más rápidos como merge sort o quick sort."}
{"prompt": "¿Cómo funciona el algoritmo de selección (selection sort)?", "response": "Busca el elemento más pequeño de la lista, lo pone al inicio, y repite el proceso con el resto. Ejemplo:\n[4, 2, 3] → menor es 2 → intercambia con 4 → [2, 4, 3]; luego menor en [4,3] es 3 → [2, 3, 4]. También es O(n²), pero hace menos intercambios que bubble sort."}
{"prompt": "¿Qué es el algoritmo de inserción (insertion sort)?", "response": "Imagina ordenar cartas en tu mano: tomas una carta y la insertas en la posición correcta entre las ya ordenadas. Es eficiente para listas pequeñas o casi ordenadas. Ejemplo:\n[3, 1, 2] → [3] (ordenado); inserta 1 → [1,3]; inserta 2 → [1,2,3]."}
{"prompt": "¿Qué significa 'O(n log n)' en ordenamiento?", "response": "Es una medida de eficiencia (complejidad). Algoritmos como merge sort y quick sort tardan tiempo proporcional a n multiplicado por log₂(n). Para 1000 elementos: ~10 000 operaciones (mucho mejor que 1 000 000 de bubble sort)."}
{"prompt": "¿Cómo funciona merge sort?", "response": "Usa 'divide y vencerás': 1) Divide la lista a la mitad, 2) Ordena cada mitad (recursivamente), 3) Combina (merge) las dos mitades ordenadas. Ejemplo:\n[3,1,4,2] → [3,1] y [4,2] → [1,3] y [2,4] → [1,2,3,4]. Siempre O(n log n), estable y confiable."}
{"prompt": "¿Qué es un recorrido en profundidad (DFS) en grafos?", "response": "DFS explora tan lejos como puede por una rama antes de retroceder. Como si entraras en un laberinto y siempre giraras a la derecha hasta topar con una pared, luego retrocedieras. Se implementa con recursión o una pila. Útil para detectar ciclos o caminos."}
{"prompt": "¿Qué es un recorrido en anchura (BFS) en grafos?", "response": "BFS explora todos los vecinos de un nodo antes de pasar a los vecinos de esos vecinos. Como las ondas al tirar una piedra en el agua. Usa una cola (queue). Útil para encontrar el camino más corto en grafos no ponderados."}
{"prompt": "¿Cómo encontrar el camino más corto en un grafo sin pesos?", "response": "Usa BFS. Como explora nivel por nivel, la primera vez que alcanzas un nodo, es por el camino más corto (en número de aristas). Ejemplo: en una red de amigos, el menor número de personas para llegar de A a Z."}
{"prompt": "¿Qué es un ciclo en un grafo?", "response": "Un ciclo es un camino que empieza y termina en el mismo nodo, sin repetir aristas. Ejemplo: A → B → C → A. Detectar ciclos es importante: en dependencias de proyectos, un ciclo significa una imposibilidad (A depende de B, B de C, C de A)."}
{"prompt": "¿Cómo saber si un grafo está conectado?", "response": "Un grafo no dirigido está conectado si desde *cualquier* nodo puedes llegar a *cualquier otro*. Puedes hacer DFS o BFS desde un nodo y ver si visitaste todos. Si sí, está conectado; si no, tiene componentes separadas."}
{"prompt": "¿Qué es quick sort y por qué es popular?", "response": "Quick sort elige un 'pivote', reordena la lista para que los menores queden a la izquierda y los mayores a la derecha, y ordena recursivamente ambas partes. En promedio es O(n log n) y muy rápido en la práctica (aunque en el peor caso es O(n²)). Es el que usa Python en sorted()."}
{"prompt": "¿Cuál es la diferencia entre merge sort y quick sort?", "response": "Merge sort siempre es O(n log n), estable y usa memoria extra. Quick sort es más rápido en la práctica, usa menos memoria, pero no es estable y puede degradarse a O(n²) si el pivote se elige mal (aunque hay estrategias para evitarlo)."}
{"prompt": "¿Qué es un grafo ponderado?", "response": "Es un grafo donde cada arista tiene un 'peso' (número): distancia, costo, tiempo, etc. Ejemplo: mapas con distancias entre ciudades. Algoritmos como Dijkstra usan estos pesos para encontrar el camino *más corto en costo*, no solo en saltos."}
{"prompt": "¿Para qué sirve el algoritmo de Dijkstra?", "response": "Encuentra el camino más corto desde un nodo inicial a *todos los demás* en un grafo con pesos positivos. Usa una cola de prioridad (min-heap). Ej: ruta más rápida de tu casa a cualquier lugar en una ciudad, considerando tiempos de tráfico."}
{"prompt": "Dame un ejercicio sencillo de ordenamiento para practicar.", "response": "¡Claro! Ejercicio: Escribe una función que ordene una lista usando *insertion sort*.\nPista: recorre desde el segundo elemento; compara con los anteriores e inserta en la posición correcta.\nEjemplo: [5, 2, 4, 6, 1, 3] → [1, 2, 3, 4, 5, 6].\nBonus: cuenta cuántas comparaciones haces para cada entrada."}